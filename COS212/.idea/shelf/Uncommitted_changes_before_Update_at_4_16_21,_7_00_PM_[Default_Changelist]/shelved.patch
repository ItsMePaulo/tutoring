Index: examprep/Exam1/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><div align=\"center\"><h1> COS 212 Semester Test 1 </h1></div>\n<div align=\"center\"><h4> BigO Notation; Self Organising Lists; Stacks & Queues; Recursion; Binary Trees </h4></div>\n\n\n## Question 1: [BigO Notation](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS212/notes/BigONotation/README.md)\n\nFor each of the following right down the complexity of the algorithm in the form of BigO Notation\n\n1.1. (1)\n```java\nint method(int i, int n) {\n    if (i < n) {\n        return 0;    \n    }\n    else if(i > n) {\n        return 1;\n    }\n    else {\n        return method(i, n -1) * method(i, n - 2)\n    }\n}\n```\n\n```java\n\n\n```\n\n1.2 (1)\n```java\nint k = 0;\nfor (int i = n; i > 0; i / 2) {\n    for (int j = 0; j < 5; j++) {\n        k++;\n    }\n}\n```\n\n```java\n\n\n```\n\n1.3 (1)\n```java\nfor (int i = 0; i < n; i++) {\n    for(int j = 0; j < n; j++) {\n        for(int k = i - 2; k <= i; k++)\n            for(int l = 0; l < n; l++) {\n                System.Println(\"hello world\")\n            }\n        }\n    }\n}\n```\n\n```java\n\n\n```\n\n1.4 (1)\n```java\nfor (int i = 0; i < n; i++) {\n    for (int p = n; p > 0; p--) {\n       a = b + c; \n    }\n}\n```\n\n````java\n\n\n````\n\n1.5 (1)\n```java\nint i = 0;\nwhile (i < n) {\n    \n    tmp = i;\n    \n    if (i % 2 == 0) {\n       tmp *= i * 2;\n    } else {\n        tmp /= i / 2;\n    }\n    i++;\n}\n```\n\n```java\n\n\n```\n\n1.6 (1)\n\n```java\nint i = 0;\nwhile (i < n) {\n    \n    if (i % 2 == 0) {\n        i *= 2;\n    } else {\n        i += 1;\n    }\n}\n```\n\n```java\n\n\n```\n\n1.7 (1)\n```java\nint method(int n) {\n    if (n < 0) {\n        return y;\n    }\n    \n    return method(n - 1) * (n - 1)\n}\n```\n```java\n\n\n```\n\n1.8 (1)\n```java\nint i = n, b = 0;\nwhile (i < n) {\n    for (int j = i - n; j < i; j++){\n        b *= j + i;\n    }\n    i--;\n}\n```\n\n```java\n\n\n```\n\n1.9 (1)\n```java\nint sum = 0;\nfor (int a = 0; a < n; a++) {\n    for (int b = 0; b < n; b++) {\n        for (int c = 0; c < n; n++) {\n            if (n > 0) {\n                return sum += a + b + c; \n            }   \n        }\n    }\n}\n```\n\n```java\n\n\n```\n1.10 (1)\n```java\nvoid method(int i, int n) {\n    \n    if (n < 0) {\n        return;\n    }\n    for ( ; i < n; i++) {\n        mehod(i, n / 2)\n    }\n}\n```\n\n```java\n\n\n```\n\n## Question 2: [Skip Lists](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS212/notes/SkipLists/README.md) + Sparse Tables\n\n2.1 Assume a Skip List with a max height of 6, provide the *Array of Powers* for the Skip List. (4)\n \n```text\n\n```\n\n2.2 What is the max level of a Skip List if there are only 4 references in the Array of Powers in the 3rd level? (1) \n\n```text\n\n```\n\n2.3 Assume the following SkipList \n\n<img src=\"../../notes/SkipLists/images/skip_list.png\" alt=\"skip list\">\n\n2.3.1 Assume Node `35` was deleted, indicate all affected Nodes, for each Node indicate at which level the Node has been \naffected, if the Node affected was the first Node you may assume `Root` at level *x*. Please only identify the Nodes \nthat will be affected when removing Node `35`. (2)\n\n```text\n\n```\n\n2.3.2 Assume Node 22 was deleted, indicate all affected Nodes, for each Node indicate at which level the Node has been \naffected, if the Node affected was the first Node you may assume `Root` at level *x*. Please only identify the Nodes \nthat will be affected when removing Node `22`. (2)\n\n```text\n\n```\n\n2.4 Assume the following Sparse Table. The top array represents Student Numbers while the secondary array represents \nclass's. Provide the implementation for the expected Node Class for elements within the Sparse Table. (3)\n\n<img src=\"images/sparse_table.png\" alt=\"sparse table image\" width=\"60%\">\n\n```java\n\n```\n\n### Question 3: [Self Organinizing Lists](https://gitlab.com/Paul_Wood_96/tutoring/-/tree/master/COS212/notes/SelfOrganizingLists/README.md)\n\n3.4 Assume you have a working implementation of the **move-to-front** strategy, being applied to the following List:\n\n> A -> B -> D -> M -> N -> F\n\nGive the final List after the Nodes have been visited in the following order. (2)\n\n> M, B, G, F, D, M\n\n```text\n\n```\n\n3.5 Assume the same List in Question 3.4 was instead implemented as a **transpose** strategy, give the final List if \nthe elements where accessed in the same order as before. You must use the initial List from question 3.4 (2)\n\n```text\n\n```\n\n3.6 Assume the Nodes in the first List where modified to now contain a counter variable the resulting List now looks as \nfollows \n\n> A/5 -> B/4 -> D/4 -> M/2 -> N/1 -> F/0\n\nGive the final List after the Nodes have been visited in the following order. (2)\n\n> F, F, M, D, N, D, A, G\n\n```text\n\n```\n\n### Question 4: [Stacks and Queues](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS212/notes/StacksAndQueus/README.md)\n\nFor all questions that follow assume the following implementation of the `Stack` class implemented as a Queue\n\n```java\nclass Stack<T extends Comparable<? super T>> extends Queue<T> {\n\n    Stack() {\n        stack = new Queue<>();\n    }\n    \n    public void push(T elem) {\n        stack.enqueu();\n    }\n    \n    public T pop() {\n        // implementation left for you\n    }\n    \n    public int size() {\n        // implementation left for you\n    }\n}\n```\n\n4.1 Implement the `pop()` method for the stack, you may assume a working `isEmpty()` method exists on the \n`Queue` class. (4)\n\n```java\n\n```\n\n4.2 Implement the `size()` method for the stack, you may also assume a working `isEmpty()` method exist on the \n`Queue` class, you may not make use of any other methods on the Queue class besides the `isEmpty()` method. (3)\n\n```java\n\n```\n\n### Question 5: [Recursion](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS212/notes/Recuriosn/README.md)\n\n5.1 Convert the following iterative method to a recursive method. This iterative method finds and returns the \nfirst occurrence of an integer in a List. The method returns -1 if the item was not found in the List. (3)\n\n```java\nint findFirstOccurance(int[] array, int element) {\n    int index = 0;\n    \n    while (index < array.length()) {\n        if (array[index] == element) {\n            return index;\n        }\n        \n        index++;\n    }\n    \n    return -1;\n}\n```\n\n```java\n\n```\n\n5.2 Convert the following recursive function to an iterative function. The following function calculates the Greatest \nCommon Denominator between two numbers. (3)\n\n```java\nint findGreatestCommonDom(int x, int y) {\n    \n    if (x == y) {\n        return x;\n    }\n    \n    if (x > y) {\n        return findGreatestCommonDom(x - y, y)\n    } else {\n        return findGreatestCommonDom(x, y - x)\n    }\n}\n\n```\n\n```java\n\n```\n\n5.3 \n\nAssume the following LinkedNode Class \n\n```java\nclass LinkedNode<T extends Comparable<? super T>> {\n    \n    int key;\n    LinkedNode<T> next;\n    \n    // constructor ...\n}\n```\n\n5.3.1 Write down a recursive method called `findFours(LinkedNode<T> node)` that takes in a LinkedNode and counts the amount of elements in the List divisible by `4`. (3)\n\n```java\n\n```\n\n5.3.2 Is your method an example of `Tail Recursion` or `Non Tail Recursion`, explain your answer. (2)\n\n```text\n\n```\n\n5.4 Assume the following sudo code for the N Queens Algorithm. Identify the base case of the algorithm (1)\n\n```kotlin\nfun placeQueen(row: Int) {\n    foreach col at a valid position\n            place queen at position\n            if (row < rows)\n                placeQueen(row + 1)\n            else\n                printBoard()\n\n    remove queen at position\n}   \n```\n\n```text\n\n```\n\n## Question 6.1 [Binary Trees](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS212/notes/BinaryTreesPart1/README.md) \n\n\n6.1.1 What is the maximum number of nodes a Binary tree can have at level 7? (1)\n\n```text\n\n```\n\n6.1.2 What is the maximum number of Leaf Nodes a Binary Tree can have at level 9? (1)\n\n```text\n\n```\n\n6.1.3 What condition must be true for both your answers in 6.1 and 6.2 to be valid? (1)\n\n```text\n\n```\n\n#### For all questions that follow, assume the following BSTNode Class\n\n```java\nclass BSTNode<T extends Comparable<? super T>> {\n    \n    T key;\n    BSTNode<T> right, left;\n    \n    // constructor\n}\n```\n\n6.1.3 Provide the simplest implementation for a *recursive* function that will return the number of Nodes in the tree that\nhave a *Right Child*. If a Nodes right Child has is not null you should consider the Node to be a valid accumulator. (3)\n\n```java\n\n\n```\n\n6.1.4 Provide the simplest implementation for an *iterative* function that will return the number of Nodes in the tree that \nhave a *Left Child*. If the Nodes left child is not null you should consider the Node to a valid accumulator. (3)\n\n```java\n\n\n```\n\n6.1.5 Provide an example of a *recursive* function that will return the largest element in a tree, your function\nshould not make use of any unnecessary parameters. (2)\n\n```java\n\n\n```\n\n## Question 6.2 [Threads](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS212/notes/BinaryTreesPart2/Part2.2/README.md)\n\n#### For all questions that follow, assume the enhanced BSTNode class \n\n```java\nclass TNode<T extends Comparable<? super T>> {\n    \n    T key;\n    TNode<T> left, right;\n    boolean hasRightThread, hasLeftThread;\n}\n```\n\n6.2.1 Integers are added into a *double-threaded* BST in the following order;\n\n> 7, 20, 12, 5, 35, 4, 9, 8, 10, 1\n\na) What is the height of the Tree (2)\n\n```text\n\n```\n\nb) How many *Left Threads* dose the resulting Tree have? (2)\n\n```text\n\n```\n\nc) Node 7 is deleted by *Merging with its Successor*, how many right threads dose the resulting Tree have? (3)\n\n```text\n\n```\n\nd) Node 9 is deleted by *Copying its Predecessor*, please draw the final Tree, with the Threads, marks will be deducted \nfor any invalid Threads. (3)\n\n```text\n\n```\n\n6.2.2 Write a method `etHeight(TNode<T> node)` which calculates the height of a sub-tree whose root is node. You may \nnot use any additional libraries. (5)\n\n```java\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examprep/Exam1/README.md b/examprep/Exam1/README.md
--- a/examprep/Exam1/README.md	(revision a3f6370e2f86606c812838744d2d9c3c68bc6911)
+++ b/examprep/Exam1/README.md	(date 1618592190440)
@@ -170,7 +170,7 @@
         return;
     }
     for ( ; i < n; i++) {
-        mehod(i, n / 2)
+        method(i, n / 2)
     }
 }
 ```
