<div align="center"><h1> Polymorphism </h1></div> 

##Compile time and Run time
Compile time code is code that is generated by the compiler before the program executes.
When we get a syntax error, that is a compile time check. The compiler (while 
the program was being compiled) could tell that it would run into an error before the 
program started running, maybe you did not declare a variable before you used it. 

Run time code is code generated by the compiler during the program execution. This can 
only be achieved using software techniques like generics and polymorphism. You will rely 
on run-time code when you know what the program needs to do but you just are not sure 
what the type of the object will be when you need to execute it. 

Imagine our earlier examples using plain [inheritance](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS110/notes/inheritance.md#how-do-we-represent-inheritance-in-uml-diagrams).
We want the our program to say hey I'm a student or hey I'm an adult when the type 
of the object is a student or the type of the object is an adult. That information is 
only going to be known at run time. Before then we just define our classes and say 
if we have a student object output a students hello and if we have an adult, output the 
adults message. 

As discussed how we get the program to execute the different methods is by making our 
function `virtual`, like so 

```c++
    virtual sayHello() {
        ..// do something specific to type
    }
```

Now the correct implementation of the `virtual sayHello()` method will be able to 
be called at run time. Before the program executes we had no idea what type was 
going created and called, but we can `bind` the correct method by making it virtual.
This technique is called binding, the compiler assigns the correct method based off 
the type of the object. 

##Abstract Base Classes and Pure Virtual Functions 
So we already know that we can `overwrite` ([override](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS110/notes/inheritance.md#virtual-methods)) 
methods that have already been declared, but what about a use case were there is 
no default implementation. 

Lets say for example we had a `EnemyFactory` class, this class by itself defines some 
similar methods fot it's 3 subclasses, `EasyEnemy`, `MediumEnemy` and `ToughEnenmy`.
Each of these 3 classes inherits from EnemyFactory, they are then the `derived` classes
from the `base` EnemyFactory. 
EnemyFactory class should define a virtual method `attack()` but the Factory should 
not be able to attack, it's by definition a factory not an enemy. The factory does 
not actually have any kind of implementation that would make sense for the attack method,
but the derived classes (the actual enemies) they do know how to attack.
We call this a `pure virtual` method meaning that the base class itself defines a 
method that does not have an implementation, and leaves the implementation to that 
of its children. This would look something like this. 

```c++
class EnemyFactory {    
    public:
        virtual void attack() = 0; 
};
```

The ` = 0` is the syntax we use to declare that this function is pure virtual, and 
to indicate that this class does not have an implementation. As soon as a class 
has 1 or more pure virtual functions, it becomes an abstract class. Abstract classes 
are special because they cannot be [instantiated](https://gitlab.com/Paul_Wood_96/tutoring/-/blob/master/COS110/notes/constructors.md#constructors-in-c) 
(we cannot create an instance of them). 
Also all pure virtual functions must be overridden in the derived class. MUST. Meaning 
the derived classes will not compile if no implementation of the base classes virtual 
function is defined.
To summarise there are 2 important caveats that you get when using pure virtual functions
1. The base class becomes an Abstract class 
2. Abstract classes cannot be instantiated and derived classes must implement the 
pure virtual method of abstract classes.

## Multiple Inheritance
As the name states this is when a derived class (child class) has two or more base 
classes (parent classes). 